<!DOCTYPE html>
<html>
<head>
<title>YUI3 use&amp;Loader 简析</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<style type="text/css">
</style>
</head>
<body>

<H2>YUI3 use&amp;Loader 简析</H2>
<p>转自: <A href="http://yiminghe.javaeye.com/blog/626182" target=_blank>http://yiminghe.javaeye.com/blog/626182</A> 
</p>
<DIV class=blog_main>
<DIV class=blog_content>
<P><SPAN style="FONT-SIZE: small">&nbsp;&nbsp;&nbsp;
YUI3和Extjs,jquery的很大不同就是对于模块的管理，对于使用动态加载脚本的方式来管理模块，记得最早由dojo提出，但是由于实现复杂且早期web开发多为小项目，就一直没有流行开来，而如今网站越来越复杂，动态加载管理模块的方式对于大团队开发能起到很好的协调作用，今天下午有空就把源码
yui-debug.js 以及
loader-debug.js读了一遍，其中combo的提议确实很精妙，但是也存在了缓存与http连接数的权衡问题：
每个页面js都不相同，如果combo到极度，那么每个页面的脚本必然都不能缓存，若完全没有combo则每个模块一个js的话，页面的http连接数将多得不可接受，不过这个自动combo的思路确实很好，搭配loader的依赖计算，以前恼人的脚本顺序问题迎刃而解。</SPAN>
</P>
<P>&nbsp;</P>
<P><SPAN style="FONT-SIZE: small">YUI3基本不再需要依赖domready，只要把use放在页面最后即可，本来就可以保障运行到js时之前的DOM树已经建立完成</SPAN>
<BR>
<STRONG><SPAN style="COLOR: #000080; FONT-SIZE: medium"><BR>
<SPAN style="COLOR: #333399">1.模块分为加载和attach两步</SPAN> </SPAN></STRONG><BR>
<BR>
<SPAN style="FONT-SIZE: small">1.1加载为使用loader载入服务器模块js代码保存到全局YUI中。<BR>
1.2.attach是在当前YUI实例上执行模块的初始化代码，使得模块在当前实例上可用。<BR>
</SPAN><BR>
<BR>
<SPAN style="COLOR: #333399"><STRONG><SPAN
	style="FONT-SIZE: medium">2.YUI种子文件初始化过程(YUI(config))</SPAN> </STRONG></SPAN><BR>
<BR>
<SPAN style="FONT-SIZE: small">1.配置初始参数设置，以及添加自定义模块<BR>
2.调用this.use("yui-base")加载 yui-base 模块 ，随之导致加载
yui,yui-later,get模块到YUI.Enc.Mods，并将以上模块attach到当前对象上下文</SPAN> <BR>
<BR>
<BR>
<BR>
<STRONG><SPAN style="COLOR: #333399; FONT-SIZE: medium">3.加载模块过程(use)</SPAN>
</STRONG><BR>
<BR>
<SPAN style="FONT-SIZE: small">1.如果该模块之前没有被加载过(YUI.Env.Mods没有)且loader也没加载，则加载loader，回调重新调用use，结束<BR>
2.loader加载了，如果该模块之前没有被加载过(YUI.Env.Mods没有)，则使用loader计算该模块的依赖项，逐一加载，<BR>
<BR>
&nbsp; 2.1 若可以combo,则先combo所有的css加载，调用_internalCallback ，然后combo所有的js加载<BR>
&nbsp; 2.2 否则挨个加载(使用Y.GET&nbsp;
_queue队列)，先把所有的css加载完，调用_internalCallback，然后加载所有的js</SPAN> <BR>
</P>
<DIV class=dp-highlighter>
<DIV class=bar>
<DIV class=tools>Js代码</DIV>
</DIV>
<OL class=dp-c>
	<LI><SPAN><SPAN class=keyword>this</SPAN><SPAN>._internalCallback&nbsp;=&nbsp;</SPAN><SPAN
		class=keyword>function</SPAN><SPAN>()&nbsp;{ &nbsp;&nbsp;</SPAN></SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN
		class=keyword>var</SPAN><SPAN>&nbsp;f&nbsp;=&nbsp;self.onCSS;
	&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN
		class=keyword>if</SPAN><SPAN>&nbsp;(f)&nbsp;{ &nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.call(self.context,&nbsp;Y);
	&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
	&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._internalCallback&nbsp;=&nbsp;</SPAN><SPAN
		class=keyword>null</SPAN><SPAN>; &nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._insert(</SPAN><SPAN
		class=keyword>null</SPAN><SPAN>,&nbsp;</SPAN><SPAN class=keyword>null</SPAN><SPAN>,&nbsp;JS);
	&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
	&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN
		class=comment>//&nbsp;_queue.running&nbsp;=&nbsp;false; </SPAN><SPAN>&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN
		class=keyword>this</SPAN><SPAN>._insert(</SPAN><SPAN class=keyword>null</SPAN><SPAN>,&nbsp;</SPAN><SPAN
		class=keyword>null</SPAN><SPAN>,&nbsp;CSS);&nbsp;&nbsp;</SPAN></LI>
</OL>
</DIV>
<PRE style="DISPLAY: none" class=js name="code">this._internalCallback = function() {
                var f = self.onCSS;
                if (f) {
                    f.call(self.context, Y);
                }
                self._internalCallback = null;
                self._insert(null, null, JS);
            };

            // _queue.running = false;
            this._insert(null, null, CSS);</PRE>
<P>&nbsp;</P>
<P>&nbsp;<SPAN style="FONT-SIZE: small">最后注意css的特殊处理，有些浏览器css不会报告加载成功状态，则不监控，添加到dom后直接报告成功<BR>
</SPAN></P>
<DIV class=dp-highlighter>
<DIV class=bar>
<DIV class=tools>Js代码</DIV>
</DIV>
<OL class=dp-c>
	<LI><SPAN><SPAN class=comment>//&nbsp;FireFox&nbsp;does&nbsp;not&nbsp;support&nbsp;the&nbsp;onload&nbsp;event&nbsp;for&nbsp;link&nbsp;nodes,&nbsp;so&nbsp;there&nbsp;is
	</SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN
		class=comment>//&nbsp;no&nbsp;way&nbsp;to&nbsp;make&nbsp;the&nbsp;css&nbsp;requests&nbsp;synchronous.&nbsp;This&nbsp;means&nbsp;that&nbsp;the&nbsp;css
	</SPAN><SPAN>&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN
		class=comment>//&nbsp;rules&nbsp;in&nbsp;multiple&nbsp;files&nbsp;could&nbsp;be&nbsp;applied&nbsp;out&nbsp;of&nbsp;order&nbsp;in&nbsp;this&nbsp;browser
	</SPAN><SPAN>&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN
		class=comment>//&nbsp;if&nbsp;a&nbsp;later&nbsp;request&nbsp;returns&nbsp;before&nbsp;an&nbsp;earlier&nbsp;one.&nbsp;&nbsp;Safari&nbsp;too.
	</SPAN><SPAN>&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN
		class=keyword>if</SPAN><SPAN>&nbsp;((ua.webkit&nbsp;||&nbsp;ua.gecko)&nbsp;&amp;&amp;&nbsp;q.type&nbsp;===&nbsp;</SPAN><SPAN
		class=string>"css"</SPAN><SPAN>)&nbsp;{ &nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_next(id,&nbsp;url);
	&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></LI>
</OL>
</DIV>
<PRE style="DISPLAY: none" class=js name="code"> // FireFox does not support the onload event for link nodes, so there is
        // no way to make the css requests synchronous. This means that the css
        // rules in multiple files could be applied out of order in this browser
        // if a later request returns before an earlier one.  Safari too.
        if ((ua.webkit || ua.gecko) &amp;&amp; q.type === "css") {
            _next(id, url);
        }    </PRE>&nbsp;
<P><SPAN style="FONT-SIZE: small">最后，调用 _onSuccess,由loader
attach所有加载模块到当前对象上下文<BR>
<BR>
3.模块被加载过，但是没有attach到当前对象Y上下文，则直接attach即可。</SPAN></P>
<P>&nbsp;</P>
<P><STRONG><SPAN style="COLOR: #333399; FONT-SIZE: medium">4.模块管理</SPAN>
</STRONG></P>
<P>&nbsp;</P>
<P><SPAN style="FONT-SIZE: small">全局命名空间YUI，保证每个模块被加载一次，但可被attach到多个YUI对象</SPAN>
</P>
<DIV class=dp-highlighter>
<DIV class=bar>
<DIV class=tools>Js代码</DIV>
</DIV>
<OL class=dp-c>
	<LI><SPAN><SPAN>YUI.Enc.Mods&nbsp;=[{ &nbsp;&nbsp;</SPAN></SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;name,
	&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fn:&nbsp;fn,&nbsp;</SPAN><SPAN
		class=comment>//模块初始化的代码 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;version:&nbsp;version,
	&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;details:&nbsp;details&nbsp;||&nbsp;{}
	&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;....]
	&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></LI>
</OL>
</DIV>
<PRE style="DISPLAY: none" class=js name="code">YUI.Enc.Mods =[{
            name: name,
            fn: fn, //模块初始化的代码
            version: version,
            details: details || {}
        } ....]
        </PRE>
<P>&nbsp;</P>
<P><STRONG><SPAN style="COLOR: #333399; FONT-SIZE: medium">5.添加模块：</SPAN>
</STRONG></P>
<P>&nbsp;</P>
<DIV class=dp-highlighter>
<DIV class=bar>
<DIV class=tools>Js代码</DIV>
</DIV>
<OL class=dp-c>
	<LI><SPAN><SPAN>YUI.add(</SPAN><SPAN class=string>'loader'</SPAN><SPAN>,&nbsp;</SPAN><SPAN
		class=keyword>function</SPAN><SPAN>(Y)&nbsp;{ &nbsp;&nbsp;</SPAN></SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=comment>//可以在Y上添加模块
	</SPAN><SPAN>&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;Y.Module1=</SPAN><SPAN
		class=keyword>function</SPAN><SPAN>(){}; &nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>},</SPAN><SPAN class=string>'3.0.0'</SPAN><SPAN>,{
	&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=comment>//加载模块前需要载入的模块
	</SPAN><SPAN>&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;requires:[], &nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=comment>//当前模块使用的模块
	</SPAN><SPAN>&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;use:[] &nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>})&nbsp;&nbsp;</SPAN></LI>
</OL>
</DIV>
<PRE style="DISPLAY: none" class=js name="code">YUI.add('loader', function(Y) {
    //可以在Y上添加模块
    Y.Module1=function(){};
   
},'3.0.0',{
    //加载模块前需要载入的模块
    requires:[],
    //当前模块使用的模块
    use:[]
})</PRE>
<P>&nbsp;</P>
<P><SPAN style="FONT-SIZE: small">每次YUI().use("module",function(Y){});
都会生成对象Y再执行模块的初始化代码，添加模块到新生成的Y上，当使用多个use时，由于闭包则会产生内存占用过多问题，最好为对一个模块的使用，放在一个use中.</SPAN></P>
<DIV class=dp-highlighter>
<DIV class=bar>
<DIV class=tools>Js代码</DIV>
</DIV>
<OL class=dp-c>
	<LI><SPAN><SPAN>YUI().use(</SPAN><SPAN class=string>"node"</SPAN><SPAN>,</SPAN><SPAN
		class=keyword>function</SPAN><SPAN>(Y1){ &nbsp;&nbsp;</SPAN></SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=keyword>var</SPAN><SPAN>&nbsp;n1=Y1.one(</SPAN><SPAN
		class=string>"#n1"</SPAN><SPAN>); &nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;n1.on(</SPAN><SPAN class=string>"click"</SPAN><SPAN>,</SPAN><SPAN
		class=keyword>function</SPAN><SPAN>(){alert(Y1);});
	&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>}); &nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>YUI().use(</SPAN><SPAN class=string>"node"</SPAN><SPAN>,</SPAN><SPAN
		class=keyword>function</SPAN><SPAN>(Y2){ &nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=keyword>var</SPAN><SPAN>&nbsp;n1=Y2.one(</SPAN><SPAN
		class=string>"#n2"</SPAN><SPAN>); &nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;n1.on(</SPAN><SPAN class=string>"click"</SPAN><SPAN>,</SPAN><SPAN
		class=keyword>function</SPAN><SPAN>(){alert(Y2);});
	&nbsp;&nbsp;</SPAN></LI>
	<LI><SPAN>});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></LI>
</OL>
</DIV>
<PRE style="DISPLAY: none" class=js name="code">YUI().use("node",function(Y1){
    var n1=Y1.one("#n1");
    n1.on("click",function(){alert(Y1);});
});

YUI().use("node",function(Y2){
    var n1=Y2.one("#n2");
    n1.on("click",function(){alert(Y2);});
});        </PRE>
<P><SPAN style="FONT-SIZE: small">&nbsp;</SPAN></P>
<P><SPAN style="FONT-SIZE: small">且&nbsp;
Y1.mix!=Y2.mix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN> &nbsp;&nbsp; <BR>
&nbsp;<BR>
<STRONG><SPAN style="COLOR: #333399; FONT-SIZE: medium">6.Loader动态加载过程</SPAN>
</STRONG></P>
<P>&nbsp;</P>
<P><SPAN style="FONT-SIZE: small">如YUI().use("node") 默认由
yui-loader计算所有缺失项，分个使用Y.Get插入到 head<BR>
<BR>
默认根据页面载入的yui种子script的src来判断base，可以使用combo来降低http连接数，有3个办法<BR>
1.自己配置combo，并设置YUI({comboBase})<BR>
2.设置base为yahoo：YUI({base:"http://yui.yahooapis.com/3.0.0/build/"})<BR>
3.最简单：页面script src直接使用yahoo:&lt;script
src="http://yui.yahooapis.com/3.0.0/build/yui/yui-debug.js"&gt;<BR>
<BR>
<BR>
总之如果：o.base &amp;&amp; (o.base.indexOf( this.comboBase.substr(0, 20))
&gt; -1); 则会使用combo来加载模块集，如 "node"的加载项<BR>
combo?3.0.0/build/oop/oop-min.js&amp;3.0.0/build/dom/dom-min.js&amp;3.0.0/build/event-custom/event-custom-base-min.js&amp;3.0.0/build/event/event-base-min.js&amp;3.0.0/build/pluginhost/pluginhost-min.js&amp;3.0.0/build/node/node-min.js&amp;3.0.0/build/event/event-delegate-min.js<BR>
</SPAN></P>
</DIV>
</DIV>

</body>
</html>